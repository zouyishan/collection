# ç®€ä»‹

éšç€ç§»åŠ¨äº’è”ç½‘çš„è“¬å‹ƒå‘å±•ï¼Œä¸šåŠ¡æ¶æ„ä¹Ÿéšä¹‹å˜å¾—é”™ç»¼å¤æ‚ï¼Œä¸šåŠ¡ç³»ç»Ÿè¶Šæ¥è¶Šå¤šã€‚é€šå¸¸ï¼Œæˆ‘ä»¬å¤„ç†æ–¹æ³•æ˜¯å¼‚æ­¥å»è°ƒå–è¿™äº›æ¥å£ã€‚éšç€é«˜å¹¶å‘ç³»ç»Ÿè¶Šæ¥è¶Šå¤šï¼Œå¼‚æ­¥å›è°ƒæ¨¡å¼ä¹Ÿè¶Šæ¥è¶Šé‡è¦ã€‚

é—®é¢˜å°±æ¥äº†ï¼Œå¦‚ä½•è·å–å¤„ç†å¼‚æ­¥è°ƒç”¨çš„ç»“æœå‘¢ ï¼Ÿè®©æˆ‘ä»¬ä¸€èµ·æ¥æ¢è®¨ä¸€ä¸‹å§ï½ï½



# Java Futureçš„å¼‚æ­¥å›è°ƒ

## Callableæ¥å£

åœ¨èŠCallableæ¥å£ä¹‹å‰ï¼Œå…ˆæä¸€ä¸‹Runnableæ¥å£ã€‚Runnableæ¥å£æ˜¯åœ¨Javaå¤šçº¿ç¨‹ä¸­è¡¨ç¤ºçº¿ç¨‹çš„ä¸šåŠ¡ä»£ç çš„æŠ½è±¡æ¥å£ã€‚ä½†æ˜¯Runnableæ²¡æœ‰è¿”å›å€¼ï¼Œä¸ºäº†è§£å†³è¿™ä¸ªé—®é¢˜ï¼ŒJavaå®šä¹‰äº†ä¸€ä¸ªå’ŒRunnableç±»ä¼¼çš„æ¥å£  --- `Callable`æ¥å£ã€‚å¹¶å°†ä¸šåŠ¡å¤„ç†æ–¹æ³•åä¸ºcall

```java
@FunctionalInterface
public interface Callable<V> {
    V call() throws Exception;
}
```

Callableæ¥å£æ˜¯ä¸€ä¸ªèŒƒå‹æ¥å£ï¼Œä¹Ÿå£°æ˜ä¸ºäº†`å‡½æ•°å¼æ¥å£`ã€‚å”¯ä¸€çš„æŠ½è±¡æ–¹æ³•callæœ‰è¿”å›å€¼ï¼Œè¿”å›å€¼ç±»å‹ä¸ºèŒƒå‹å½¢å‚çš„å®é™…ç±»å‹



## åˆæ¢FutureTaskç±»

æ•…åæ€æ„ï¼ŒFutureTaskç±»ä»£è¡¨ä¸€ä¸ªæœªæ¥æ‰§è¡Œçš„ä»»åŠ¡ï¼Œè¡¨ç¤ºæ–°çº¿ç¨‹æ‰§è¡Œçš„æ“ä½œã€‚åŒæ—¶ä¹Ÿä½äº`java.util.concurrent`åŒ…ä¸­ã€‚æºç å¦‚ä¸‹ï¼š

```java
public class FutureTask<V> implements RunnableFuture<V> {
    public FutureTask(Callable<V> callable) {
        if (callable == null)
            throw new NullPointerException();
        this.callable = callable;
        this.state = NEW;       // ensure visibility of callable
    }
}
```

**FutureTaskç±»å°±åƒä¸€åº§æ­åœ¨Callableå®ä¾‹ä¸Threadçº¿ç¨‹å®ä¾‹ä¹‹é—´çš„æ¡¥**ã€‚FutureTaskå†…éƒ¨å°è£…äº†ä¸€ä¸ªCallableå®ä¾‹ï¼Œç„¶åè‡ªèº«åˆä½œä¸ºThreadçº¿ç¨‹çš„targetã€‚



## Futureæ¥å£

Futureæ¥å£å¹¶ä¸å¤æ‚ï¼Œä¸»è¦æ˜¯å¯¹å¹¶å‘ä»»åŠ¡çš„æ‰§è¡ŒåŠè·å–å…¶ç»“æœçš„ä¸€äº›æ“ä½œã€‚ä¸»è¦æœ‰ä¸‰å¤§åŠŸèƒ½ã€‚

* åˆ¤æ–­å¹¶å‘ä»»åŠ¡æ˜¯å¦æ‰§è¡Œå®Œã€‚
* è·å–å¹¶å‘çš„ä»»åŠ¡å®Œæˆåçš„ç»“æœ
* å–æ¶ˆå¹¶å‘æ‰§è¡Œçš„ä»»åŠ¡

```java
package java.util.concurrent;
public interface Future<V> {
  boolean cancel(boolean mayInterruptIfRunning);
  boolean isCancelled();
  boolean isDone();
  V get() throws InterruptedException, ExecutionException;
  V get(long timeout, TimeUnit unit)
        throws InterruptedException, ExecutionException, TimeoutException;
}
```



è¯¦ç»†è¯´æ³•å¦‚ä¸‹ï¼š

* V get()ï¼šè·å–å¹¶å‘ä»»åŠ¡æ‰§è¡Œçš„ç»“æœã€‚è¿™ä¸ªæ–¹æ³•æ˜¯é˜»å¡çš„ï¼Œå¦‚æœå¹¶å‘ä»»åŠ¡æ²¡æœ‰æ‰§è¡Œå®Œæˆè°ƒç”¨æ­¤æ–¹æ³•çš„çº¿ç¨‹ä¼šä¸€ç›´é˜»å¡
* V get(Long timeout, TimeUtil unit)ï¼šè·å–å¹¶å‘ä»»åŠ¡æ‰§è¡Œçš„ç»“æœã€‚ä¹Ÿæ˜¯é˜»å¡çš„ï¼Œä½†æ˜¯æœ‰é˜»å¡çš„æ—¶é—´é™åˆ¶ï¼Œå¦‚æœé˜»å¡æ—¶é—´è¶…è¿‡è®¾å®šçš„æ—¶é—´ï¼Œè¯¥æ–¹æ³•å°†ä¼šæŠ›å‡ºå¼‚å¸¸
* boolean isDone()ï¼šè·å–å¹¶å‘ä»»åŠ¡çš„çŠ¶æ€æ˜¯å¦ç»“æŸ
* boolean isCancelled()ï¼šè·å–å¹¶å‘ä»»åŠ¡çš„å–æ¶ˆçŠ¶æ€ã€‚å¦‚æœä»»åŠ¡è¢«å–æ¶ˆè¿”å›true
* boolean cancel(boolean mayInterruptIfRunning)ï¼šå–æ¶ˆå¹¶å‘ä»»åŠ¡çš„æ‰§è¡Œ



## å†æ¢FutureTaskç±»

åœ¨FutureTaskç±»ä¸­ï¼Œæœ‰ä¸€ä¸ªCallableçš„ç§æœ‰æˆå‘˜ï¼ŒFuturetaskå†…éƒ¨æœ‰ä¸€ä¸ªrunæ–¹æ³•ã€‚è¿™ä¸ªrunæ–¹æ³•æ˜¯Runableæ¥å£çš„æŠ½è±¡æ–¹æ³•ï¼Œåœ¨FutureTaskç±»çš„å†…éƒ¨æä¾›äº†è‡ªå·±çš„å®ç°ã€‚åœ¨Threadçº¿ç¨‹å®ä¾‹æ‰§è¡Œæ—¶ï¼Œä¼šå°†è¿™ä¸ªrunæ–¹æ³•ä½œä¸ºtargetç›®æ ‡å»å¼‚æ­¥æ‰§è¡Œã€‚åœ¨FutureTaskå†…éƒ¨çš„runæ–¹æ³•ä¸­å®é™…æ˜¯ä¼šæ‰§è¡ŒCallableçš„callæ–¹æ³•ã€‚

æ‰§è¡Œå®Œåç»“æœä¼šä¿å­˜åœ¨ç§æœ‰æˆå‘˜-- outcomeå±æ€§ä¸­

```java
private Object outcome; // non-volatile, protected by state reads/writes
```

outcomeè´Ÿè´£ä¿å­˜ç»“æœã€‚ç„¶åFutureTaské€šè¿‡getæ–¹æ³•è·å–è¿™ä¸ªobjectçš„å€¼ï¼Œé‚£è¿™ä¸ªFutureTaskçš„ä»»åŠ¡ä¹Ÿå°±èƒ½æˆåŠŸå®Œæˆäº†ã€‚

```java
public void run() {
  if (state != NEW ||
      !UNSAFE.compareAndSwapObject(this, runnerOffset,
                                   null, Thread.currentThread()))
    return;
  try {
    Callable<V> c = callable;
    if (c != null && state == NEW) {
      V result;
      boolean ran;
      try {
        result = c.call();
        ran = true;
      } catch (Throwable ex) {
        result = null;
        ran = false;
        setException(ex);
      }
      if (ran)
        // å°†resultä¿å­˜åˆ°outcomeä¸­
        set(result);
    }
  } finally {
    // runner must be non-null until state is settled to
    // prevent concurrent calls to run()
    runner = null;
    // state must be re-read after nulling runner to prevent
    // leaked interrupts
    int s = state;
    if (s >= INTERRUPTING)
      handlePossibleCancellationInterrupt(s);
  }
}
```



## å®ä¾‹



```java
package com.zou;

import java.util.concurrent.FutureTask;
import java.util.concurrent.TimeUnit;


public class futureTask {
    public static void main(String[] args) throws Exception {
        FutureTask<Boolean> TaskA = new FutureTask<>(() -> {
            try {
                TimeUnit.SECONDS.sleep(2);
                System.out.println("Aä»»åŠ¡å‡†å¤‡å¥½äº†ğŸ‘Œ");
            } catch (Exception e) {
                System.out.println("Aä»»åŠ¡å‡ºé—®é¢˜äº†");
                return false;
            }
            System.out.println("Aä»»åŠ¡è¿è¡Œç»“æŸ");
            return true;
        });

        FutureTask<Boolean> TaskB = new FutureTask<>(() -> {
            try {
                TimeUnit.SECONDS.sleep(4);
                System.out.println("Bä»»åŠ¡å‡†å¤‡å¥½äº†ğŸ‘Œ");
            } catch (Exception e) {
                System.out.println("Bä»»åŠ¡å‡ºé—®é¢˜äº†");
                return false;
            }
            System.out.println("Bä»»åŠ¡è¿è¡Œç»“æŸ");
            return true;
        });

        Thread threadA = new Thread(TaskA);
        Thread threadB = new Thread(TaskB);

        threadA.start();
        threadB.start();

        Thread.currentThread().setName("ä¸»çº¿ç¨‹");
        try {
            boolean a = TaskA.get();
            boolean b = TaskB.get();
            isReady(a, b);
        } catch (Exception e) {
            System.out.println("å‘ç”Ÿäº†ä¸­æ–­");
        }
        System.out.println("è¿è¡Œç»“æŸ");
    }
    public static void isReady(boolean a, boolean b) {
        if (a && b) {
            System.out.println("éƒ½å‡†å¤‡å¥½äº†");
        } else if (!a) {
            System.out.println("Aæ²¡å‡†å¤‡å¥½");
        } else {
            System.out.println("Bæ²¡å‡†å¤‡å¥½");
        }
    }
}
```

è¿è¡Œç»“æœä¸ºï¼š

```txt
Aä»»åŠ¡å‡†å¤‡å¥½äº†ğŸ‘Œ
Aä»»åŠ¡è¿è¡Œç»“æŸ
Bä»»åŠ¡å‡†å¤‡å¥½äº†ğŸ‘Œ
Bä»»åŠ¡è¿è¡Œç»“æŸ
éƒ½å‡†å¤‡å¥½äº†
è¿è¡Œç»“æŸ

```

è¦æ˜¯å°†ä¸Šé¢çš„ä»£ç è·‘ä¸€ä¸‹ä¼šå‘ç°ï¼Œè¿™é‡Œçš„`FutureTask`ç±»çš„getæ–¹æ³•ï¼Œå¼‚æ­¥è·å–ç»“æœçš„åŒæ—¶ï¼Œä¸»çº¿ç¨‹æ˜¯é˜»å¡çš„ã€‚æ‰€ä»¥å¯ä»¥å°†å…¶å½’ä¸ºå¼‚æ­¥é˜»å¡æ¨¡å¼ã€‚

å¼‚æ­¥é˜»å¡çš„æ•ˆç‡å¾€å¾€æ˜¯æ¯”è¾ƒä½çš„ï¼Œè¢«é˜»å¡çš„ä¸»çº¿ç¨‹ä¸èƒ½å¹²ä»»ä½•äº‹ã€‚å¹¶æ²¡æœ‰å®ç°éé˜»å¡çš„å¼‚æ­¥ç»“æœè·å–æ–¹æ³•ã€‚å¦‚æœéœ€è¦ç”¨åˆ°è·å–å¼‚æ­¥ç»“æœï¼Œåˆ™éœ€è¦å¼•å…¥ä¸€äº›æ¡†æ¶ï¼Œå…ˆä»‹ç»ä¸€ä¸‹Googleçš„Guavaæ¡†æ¶



# Guavaçš„å¼‚æ­¥å›è°ƒ

Guavaæ˜¯Googleæä¾›çš„Javaæ‰©å±•åŒ…ï¼Œæä¾›ä¸€ç§å¼‚æ­¥å›è°ƒçš„è§£å†³æ–¹æ¡ˆã€‚ç›¸å…³çš„æºç åœ¨`com.google.common.util.concurrent`åŒ…ä¸­ã€‚åŒ…ä¸­å¾ˆå¤šç±»ï¼Œéƒ½æ˜¯å¯¹`java.util.concurrent`èƒ½åŠ›çš„æ‰©å±•å’Œå¢å¼ºã€‚æ¯”å¦‚Guavaçš„å¼‚æ­¥ä»»åŠ¡æ¥å£`ListenableFuture`, å®ç°äº†éé˜»å¡è·å–å¼‚æ­¥ç»“æœçš„åŠŸèƒ½ã€‚

å¯¹äºå¼‚æ­¥å›è°ƒï¼ŒGuavaä¸»è¦åšäº†ä»¥ä¸‹å¢å¼ºï¼š

* å¼•å…¥ä¸€ä¸ªæ–°çš„æ¥å£`ListenableFuture`ï¼Œç»§æ‰¿äº†Javaçš„Futureæ¥å£ï¼Œä½¿å¾—Javaçš„Futureå¼‚æ­¥ä»»åŠ¡ï¼Œåœ¨Guavaä¸­èƒ½è¢«ç›‘æ§å’Œè·å¾—éé˜»å¡å¼‚æ­¥æ‰§è¡Œçš„ç»“æœã€‚
* å¼•å…¥ä¸€ä¸ªæ–°çš„æ¥å£`FutureCallback`ï¼Œè¿™æ˜¯ä¸€ä¸ª**ç‹¬ç«‹çš„æ–°æ¥å£**ã€‚è¯¥æ¥å£çš„ç›®çš„æ˜¯åœ¨å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œå®Œæˆåï¼Œ**æ ¹æ®å¼‚æ­¥ç»“æœï¼Œå®Œæˆä¸åŒçš„å›è°ƒå¤„ç†ï¼Œå¹¶ä¸”å¯ä»¥å¤„ç†å›è°ƒç»“æœ**ã€‚



## è¯¦è§£FutureCallback

`FutureCallback`æ˜¯ä¸€ä¸ªæ–°å¢çš„æ¥å£ï¼Œç”¨æ¥å¡«å†™å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œå®Œåçš„ç›‘å¬é€»è¾‘ã€‚æœ‰ä¸¤ä¸ªå›è°ƒæ–¹æ³•ï¼š

* onSuccessæ–¹æ³•ï¼Œåœ¨å¼‚æ­¥ä»»åŠ¡æ‰§è¡ŒæˆåŠŸåå›è°ƒï¼›è°ƒç”¨æ—¶ï¼Œå¼‚æ­¥ä»»åŠ¡çš„æ‰§è¡Œç»“æœä½œä¸ºonSuccessæ–¹æ³•çš„å‚æ•°ä¼ å…¥
* onFailureæ–¹æ³•ï¼Œåœ¨å¼‚æ­¥ä»»åŠ¡æ‰§è¡Œè¿‡ç¨‹ä¸­ï¼ŒæŠ›å‡ºå¼‚å¸¸æ—¶è¢«å›è°ƒï¼›è°ƒç”¨æ—¶å¼‚æ­¥ä»»åŠ¡æ‰€æŠ›å‡ºçš„å¼‚å¸¸ï¼Œä½œä¸ºonFailureæ–¹æ³•çš„å‚æ•°ä¼ å…¥ã€‚

FutureCallbackçš„æºä»£ç å¦‚ä¸‹ï¼š

```java
public interface FutureCallback<V> {
  /** Invoked with the result of the {@code Future} computation when it is successful. */
  void onSuccess(@Nullable V result);

  /**
   * Invoked when a {@code Future} computation fails or is canceled.
   *
   * <p>If the future's {@link Future#get() get} method throws an {@link ExecutionException}, then
   * the cause is passed to this method. Any other thrown object is passed unaltered.
   */
  void onFailure(Throwable t);
}
```



æ³¨æ„ï¼ŒGuavaçš„FutureCallableä¸Javaçš„Callableï¼Œåå­—ç›¸è¿‘ï¼Œä½†å®è´¨ä¸åŒï¼Œå­˜åœ¨æœ¬è´¨çš„åŒºåˆ«ï¼š

1. Javaçš„Callableæ¥å£ï¼Œä»£è¡¨çš„æ˜¯ä¸€éƒ¨æ‰§è¡Œçš„é€»è¾‘
2. Guavaçš„FutureCallbackæ¥å£ï¼Œä»£è¡¨çš„æ˜¯Callableå¼‚æ­¥é€»è¾‘æ‰§è¡Œå®Œä¹‹åï¼Œæ ¹æ®æˆåŠŸæˆ–è€…å¤±è´¥çš„ä¸¤ç§æƒ…å†µçš„å–„åå·¥ä½œ

é‚£ä¹ˆé—®é¢˜æ¥äº†ï¼ŒGuavaå¦‚ä½•å®ç°å¼‚æ­¥ä»»åŠ¡Callableå’ŒFutureCallableç»“æœå›è°ƒä¹‹é—´çš„ç›‘æ§å…³ç³»å‘¢ï¼ŸGuavaå¼•å…¥äº†ä¸€ä¸ªæ–°æ¥å£ListenableFutureï¼Œå®ƒç»§æ‰¿äº†Javaçš„Futureæ¥å£ï¼Œå¢å¼ºäº†ç›‘æ§èƒ½åŠ›ã€‚



## è¯¦è§£ListenableFuture

`Guava`çš„`ListenableFuture`æ¥å£æ˜¯å¯¹Javaçš„Futureæ¥å£çš„æ‰©å±•ï¼Œå¯ä»¥ç†è§£ä¸ºå¼‚æ­¥ä»»åŠ¡çš„å®ä¾‹ã€‚æºä»£ç å¦‚ä¸‹ï¼š

```java
public interface ListenableFuture<V> extends Future<V> {
  void addListener(Runnable listener, Executor executor);
}
```

`ListenableFuture`ä»…ä»…å¢åŠ äº†ä¸€ä¸ªæ–¹æ³• -- addListeneræ–¹æ³•ã€‚ä»–çš„ä½œç”¨æ˜¯å°†å‰ä¸€å°èŠ‚çš„FutureCallbackå–„åå›è°ƒå·¥ä½œï¼Œå°è£…æˆä¸€ä¸ªå†…éƒ¨çš„Runnableå¼‚æ­¥å›è°ƒä»»åŠ¡ï¼Œ**åœ¨Callableå¼‚æ­¥ä»»åŠ¡å®Œæˆåï¼Œå›è°ƒFutureCallbackè¿›è¡Œå–„åå¤„ç†**

åœ¨å®é™…ç¼–ç¨‹ä¸­ï¼Œå¦‚ä½•å°†FutureCallbackå›è°ƒé€»è¾‘ç»‘å®šåˆ°å¼‚æ­¥çš„ListenableFutureä»»åŠ¡å‘¢ï¼Ÿå¯ä»¥ä½¿ç”¨Guabaçš„Futureså·¥å…·ç±»ï¼Œä»–æœ‰ä¸€ä¸ªaddCallbacké™æ€æ–¹æ³•ï¼Œå¯ä»¥å°†FutureCallbackçš„å›è°ƒå®ä¾‹ç»‘å®šåˆ°ListenableFutureå¼‚æ­¥ä»»åŠ¡ã€‚ç±»ä¼¼è¿™æ ·çš„ç»‘å®šï¼š

```java
Futures.addCallback(ListenableFuture, new FutureCallback<Object>() {

  @Override
  public void onSuccess(@Nullable Object result) {

  }

  @Override
  public void onFailure(Throwable t) {

  }
}, executors);
```

åŒæ—¶ï¼Œé—®é¢˜æ¥äº†ï¼ŒGuavaéƒ½æ˜¯å¯¹Futureå¼‚æ­¥ä»»åŠ¡çš„æ‰©å±•ï¼Œä½†æ˜¯Guavaçš„å¼‚æ­¥ä»»åŠ¡ä»ä½•è€Œæ¥ï¼Ÿ



## è·å–ListenableFutureå¼‚æ­¥ä»»åŠ¡

è¦è·å–Guavaçš„ListenableFutureå¼‚æ­¥ä»»åŠ¡å®ä¾‹ï¼Œä¸»è¦æ˜¯é€šè¿‡å‘çº¿ç¨‹æ± æäº¤Callableä»»åŠ¡çš„æ–¹å¼æ¥è·å–ã€‚ä¸è¿‡è¿™é‡Œæ‰€è¯´çš„çº¿ç¨‹æ± ä¸æ˜¯Javaçš„çº¿ç¨‹æ± ï¼Œè€Œæ˜¯Guavaè‡ªå·±çš„çº¿ç¨‹æ± ã€‚

Guavaçº¿ç¨‹æ± æ˜¯å¯¹Javaçº¿ç¨‹æ± çš„ä¸€ç§è£…é¥°ï¼Œåˆ›å»ºGuavaçº¿ç¨‹æ± çš„æ–¹å¼å¦‚ä¸‹ï¼š

```java
ExecutorService jPool = Executors.newFixedThreadPool(10);
ListeningExecutorService Pool = MoreExecutors.listeningDecorator(jPool);
```

**å…ˆåˆ›å»ºä¸€ä¸ªJavaçš„çº¿ç¨‹æ± ï¼Œåœ¨ä½œä¸ºGuavaçº¿ç¨‹æ± çš„å‚æ•°ä¼ è¿›å»å¾—åˆ°Guavaçš„çº¿ç¨‹æ± ï¼Œç„¶åæˆ‘ä»¬é€šè¿‡subimtæäº¤ä»»åŠ¡å°±å¯ä»¥è·å¾—ListenableFutureå¼‚æ­¥ä»»åŠ¡å®ä¾‹äº†**

```java
ListenableFuture<Boolean> task = Pool.submit(() -> {
    return true;
});

Futures.addCallback(task, new FutureCallback<Boolean>() {
    @Override
    public void onSuccess(@Nullable Boolean result) {
      
    }

    @Override
    public void onFailure(Throwable t) {

    }
}, jPool);
```



## å®ä¾‹

```java
package com.zou;

import com.google.common.util.concurrent.*;
import org.checkerframework.checker.nullness.qual.Nullable;

import java.util.concurrent.ExecutorService;
import java.util.concurrent.Executors;
import java.util.concurrent.TimeUnit;

public class guava {
    public static void main(String[] args) throws Exception {
      	// åˆ›å»º Guavaçº¿ç¨‹æ± 
        ExecutorService jPool = Executors.newFixedThreadPool(10);
        ListeningExecutorService Pool = MoreExecutors.listeningDecorator(jPool);

      	// è·å–ListenableFutureå¼‚æ­¥ä»»åŠ¡
        ListenableFuture<Boolean> task = Pool.submit(() -> {
            TimeUnit.SECONDS.sleep(2);
            System.out.println("å‰¯çº¿ç¨‹å¼€å§‹æ‰§è¡Œ");
            return true;
        });
				
      	// åšå›è°ƒ
        Futures.addCallback(task, new FutureCallback<Boolean>() {
            @Override
            public void onSuccess(@Nullable Boolean result) {
                System.out.println("æ‰§è¡ŒæˆåŠŸ");
            }

            @Override
            public void onFailure(Throwable t) {
                System.out.println("æ‰§è¡Œå¤±è´¥");
                t.printStackTrace();
            }
        }, jPool);

        TimeUnit.SECONDS.sleep(1);
        System.out.println("ä¸»çº¿ç¨‹æ‰§è¡Œå®Œæˆ");

    }
}
```

ç»“æœä¸ºï¼š

```txt
ä¸»çº¿ç¨‹æ‰§è¡Œå®Œæˆ
å‰¯çº¿ç¨‹å¼€å§‹æ‰§è¡Œ
æ‰§è¡ŒæˆåŠŸ
```

å¯ä»¥å‘ç°ç¨‹åºå·²ç»æ˜¯å¼‚æ­¥éé˜»å¡äº†ã€‚

Guavaå¼‚æ­¥å›è°ƒå’ŒJavaçš„FutureTaskå¼‚æ­¥å›è°ƒï¼Œæœ¬è´¨çš„ä¸åŒåœ¨äºï¼›

* Guavaæ˜¯éé˜»å¡çš„å¼‚æ­¥å›è°ƒï¼Œè°ƒç”¨çº¿ç¨‹æ˜¯ä¸é˜»å¡çš„ï¼Œå¯ä»¥ç»§ç»­æ‰§è¡Œè‡ªå·±çš„ä¸šåŠ¡é€»è¾‘
* FutureTaskæ˜¯é˜»å¡çš„å¼‚æ­¥å›è°ƒï¼Œè°ƒç”¨çº¿ç¨‹æ˜¯é˜»å¡çš„ï¼Œåœ¨è·å–å¼‚æ­¥ç»“æœçš„è¿‡ç¨‹ä¸­ï¼Œä¸€ç›´é˜»å¡ï¼Œç­‰å¾…å¼‚æ­¥çº¿ç¨‹è¿”å›ç»“æœ



# Nettyçš„å¼‚æ­¥å›è°ƒ

Nettyå®˜æ–¹æ–‡æ¡£ä¸­æŒ‡å‡ºNettyçš„ç½‘ç»œæ“ä½œéƒ½æ˜¯å¼‚æ­¥çš„ã€‚åœ¨Nettyæºç ä¸­ï¼Œå¤§é‡ä½¿ç”¨å¼‚æ­¥å›è°ƒå¤„ç†æ¨¡å¼ã€‚åœ¨Nettyçš„ä¸šåŠ¡å¼€å‘å±‚é¢ï¼ŒNettyåº”ç”¨çš„Handlerå¤„ç†å™¨ä¸­çš„ä¸šåŠ¡å¤„ç†ä»£ç ï¼Œä¹Ÿéƒ½æ˜¯å¼‚æ­¥æ‰§è¡Œçš„ã€‚æ‰€ä»¥ï¼Œäº†è§£Nettyçš„å¼‚æ­¥å›è°ƒæ˜¯å¾ˆæœ‰å¿…è¦è€Œä¸”å¾ˆé‡è¦çš„ã€‚

åŒæ ·ï¼ŒNettyç»§æ‰¿å’Œæ‰©å±•äº†JDK Futureç³»åˆ—å¼‚æ­¥å›è°ƒçš„APIï¼Œå®šä¹‰äº†è‡ªèº«çš„Futureç³»åˆ—æ¥å£å’Œç±»ï¼Œå®ç°äº†å¼‚æ­¥ä»»åŠ¡çš„ç›‘æ§ï¼Œå¼‚æ­¥æ‰§è¡Œç»“æœçš„è·å–ã€‚

æ€»ä½“æ¥è¯´ï¼ŒNettyå¯¹JavaFutureå¼‚æ­¥ä»»åŠ¡æ‰©å±•å¦‚ä¸‹ï¼š

* ç»§æ‰¿Javaçš„Futureæ¥å£ï¼Œå¾—åˆ°ä¸€ä¸ªæ–°çš„å±äºNettyè‡ªå·±çš„Futureå¼‚æ­¥ä»»åŠ¡æ¥å£ï¼Œè¯¥æ¥å£å¯¹åŸæœ‰çš„æ¥å£è¿›è¡Œäº†å¢å¼ºï¼Œä½¿å¾—Nettyå¼‚æ­¥ä»»åŠ¡èƒ½å¤Ÿä»¥éé˜»å¡çš„æ–¹å¼å¤„ç†å›è°ƒçš„ç»“æœã€‚**Nettyæ²¡æœ‰ä¿®æ”¹Futureçš„åç§°ï¼Œåªæ˜¯è°ƒæ•´äº†æ‰€åœ¨çš„åŒ…å**ã€‚
* å¼•å…¥äº†ä¸€ä¸ªæ–°æ¥å£ -- GenericFutureListener, **ç”¨äºè¡¨ç¤ºå¼‚æ­¥æ‰§è¡Œå®Œçš„ç›‘å¬å™¨**ã€‚Nettyä½¿ç”¨äº†ç›‘å¬å™¨æ¨¡å¼ï¼Œå¼‚æ­¥ä»»åŠ¡çš„æ‰§è¡Œå®Œæˆåçš„å›è°ƒé€»è¾‘æŠ½è±¡æˆäº†Listenerç›‘å¬å™¨æ¥å£ã€‚å¯ä»¥å°†Nettyçš„GenericFutureListenerç›‘å¬å™¨æ¥å£åŠ å…¥Nettyå¼‚æ­¥ä»»åŠ¡Futureä¸­ï¼Œå®ç°å¯¹å¼‚æ­¥ä»»åŠ¡æ‰§è¡ŒçŠ¶æ€çš„äº‹ä»¶ç›‘å¬ã€‚

æ€»ä½“æ¥è¯´è®¾è®¡æ€è·¯å’ŒGuavaå·®ä¸å¤šã€‚å¯¹åº”å…³ç³»ä¸ºï¼š

* Nettyçš„Futureæ¥å£ï¼Œå¯ä»¥å¯¹åº”åˆ°Guavaçš„ListenableFutureæ¥å£ã€‚
* Nettyçš„GenericFutureListeneræ¥å£ï¼Œå¯ä»¥å¯¹åº”åˆ°Guavaçš„FutureCallbackæ¥å£ã€‚



## è¯¦è§£GenericFutureListeneræ¥å£

å‰é¢æåˆ°ï¼Œå’ŒGuavaçš„FutureCallbackä¸€æ ·ï¼ŒNettyæ–°å¢äº†ä¸€ä¸ªæ¥å£æ¥å°è£…å¼‚æ­¥éé˜»å¡å›è°ƒçš„é€»è¾‘ ----- å®ƒå°±æ˜¯GenericFutureListeneræ¥å£ã€‚

GenericFutureListenerä½äº`io.netty.util.concurrent`åŒ…ä¸­ï¼Œæºç å¦‚ä¸‹ï¼š

```java
public interface GenericFutureListener<F extends Future<?>> extends EventListener {

    /**
     * Invoked when the operation associated with the {@link Future} has been completed.
     *
     * @param future  the source {@link Future} which called this callback
     */
    void operationComplete(F future) throws Exception;
}
```

GenericFutureListeneræ‹¥æœ‰ä¸€ä¸ªå›è°ƒæ–¹æ³•ï¼šoperationCompleteï¼Œè¡¨ç¤ºå¼‚æ­¥ä»»åŠ¡æ“ä½œå®Œæˆã€‚åœ¨Futureå¼‚æ­¥ä»»åŠ¡æ‰§è¡Œå®Œæˆåï¼Œå°†å›è°ƒæ­¤æ–¹æ³•ã€‚

è¿™é‡Œçš„`EventListener`æ˜¯ä¸€ä¸ªç©ºæ¥å£ï¼Œæ²¡æœ‰ä»»ä½•æŠ½è±¡æ–¹æ³•ï¼Œæ˜¯ä¸€ä¸ªä»…ä»…å…·æœ‰è¡¨ç¤ºä½œç”¨çš„æ¥å£ã€‚



## è¯¦è§£Nettyçš„Futureæ¥å£

Nettyçš„futureæ¥å£å¯¹ä¸€ç³»åˆ—çš„æ–¹æ³•åšäº†æ‰©å±•ï¼Œå¯¹æ‰§è¡Œçš„è¿‡ç¨‹è¿›è¡Œäº†ç›‘æ§ï¼Œå¯¹å¼‚æ­¥å›è°ƒå®Œæˆäº‹ä»¶è¿›è¡Œäº†ç›‘å¬ã€‚Nettyçš„Futureæ¥å£çš„æºä»£ç å¦‚ä¸‹ï¼š

```java
public interface Future<V> extends java.util.concurrent.Future<V> {
  // å¢åŠ å¼‚æ­¥ä»»åŠ¡æ˜¯å¦å®Œæˆçš„ç›‘å¬å™¨
	Future<V> addListener(GenericFutureListener<? extends Future<? super V>> listener);
  // ç§»é™¤å¼‚æ­¥ä»»åŠ¡æ˜¯å¦æ‰§è¡Œå®Œæˆçš„ç›‘å¬å™¨
  Future<V> removeListener(GenericFutureListener<? extends Future<? super V>> listener);
  .........
}
```

Nettyçš„Futureæ¥å£ä¸€èˆ¬ä¸ä¼šç›´æ¥ä½¿ç”¨ï¼Œè€Œæ˜¯ä¼šä½¿ç”¨å­æ¥å£ã€‚Nettyæœ‰ä¸€ç³»åˆ—çš„å­æ¥å£ï¼Œä»£è¡¨ä¸åŒç±»å‹çš„å¼‚æ­¥ä»»åŠ¡ï¼Œå¦‚ChannelFutureæ¥å£ã€‚

ChannelFutureå­æ¥å£è¡¨ç¤º**é€šé“IOæ“ä½œçš„å¼‚æ­¥ä»»åŠ¡**ï¼›å¦‚æœåœ¨é€šé“çš„å¼‚æ­¥IOæ“ä½œå®Œæˆåï¼Œéœ€è¦æ‰§è¡Œå›è°ƒæ“ä½œï¼Œå°±éœ€è¦ä½¿ç”¨åˆ°ChannelFutureã€‚



## ChannelFutureçš„ä½¿ç”¨

åœ¨Nettyç½‘ç»œç¼–ç¨‹ä¸­ï¼Œç½‘ç»œè¿æ¥é€šé“çš„è¾“å…¥å’Œè¾“å‡ºå¤„ç†éƒ½æ˜¯å¼‚æ­¥è¿›è¡Œçš„ï¼Œéƒ½ä¼šè¿”å›ä¸€ä¸ªChannelFutureæ¥å£çš„å®ä¾‹ã€‚é€šè¿‡è¿”å›çš„å¼‚æ­¥ä»»åŠ¡å®ä¾‹ï¼Œå¯ä»¥ä¸ºå®ƒå¢åŠ å¼‚æ­¥å›è°ƒçš„ç›‘å¬å™¨ã€‚åœ¨å¼‚æ­¥ä»»åŠ¡çœŸæ­£ç»“æŸåï¼Œå›è°ƒæ‰æ‰§è¡Œã€‚

Nettyçš„ç½‘ç»œè¿æ¥çš„å¼‚æ­¥å›è°ƒï¼Œå®ä¾‹ä»£ç å¦‚ä¸‹ï¼š

```java
Bootstrap bootstrap = new Bootstrap();
ChannelFuture connect = bootstrap.connect("localhost", 6666);

connect.addListener(new ChannelFutureListener() {
  @Override
  public void operationComplete(ChannelFuture future) throws Exception {
    if (future.isSuccess()) {
      // æˆåŠŸ
      System.out.println("yes");
    } else {
      // å¤±è´¥
      System.out.println("exception");
      future.cause().printStackTrace();
    }
  }
});
```

GenericFutureListeneræ¥å£åœ¨Nettyä¸­æ˜¯ä¸€ä¸ªåŸºç¡€ç±»å‹æ¥å£ã€‚åœ¨ç½‘ç»œç¼–ç¨‹çš„å¼‚æ­¥å›è°ƒä¸­ï¼Œä¸€èˆ¬ä½¿ç”¨Nettyä¸­æä¾›çš„æŸä¸ªå­æ¥å£ï¼Œå¦‚ChannelFutureListeneræ¥å£ã€‚



# æ€»ç»“

å¥½å•¦ï¼Œå¼‚æ­¥å›è°ƒçš„éƒ¨åˆ†åŸºæœ¬å°±åˆ°è¿™é‡Œäº†ã€‚éšç€é«˜å¹¶å‘ç³»ç»Ÿè¶Šæ¥è¶Šå¤šï¼Œå¼‚æ­¥å›è°ƒæ¨¡å¼ä¹Ÿè¶Šæ¥è¶Šé‡è¦ã€‚æˆ‘ä»¬æ¥å›å¿†ä¸€ä¸‹ä¸»è¦è®²äº†é‚£äº›å¼‚æ­¥å›è°ƒå§ï½

**Javaè‡ªå¸¦çš„å¼‚æ­¥å›è°ƒ**ï¼š

* Futureä½œä¸ºæ¥å£ï¼Œå¯¹åº”çš„FutureTaskä¸­çš„getæ–¹æ³•ä½œä¸ºç»“æœçš„å›è°ƒã€‚ä½†æ­¤æ˜¯å¼‚æ­¥é˜»å¡çš„

**Guavaå¼‚æ­¥å›è°ƒ**ï¼š

* ListenableFutureä½œä¸ºæ¥å£ï¼Œå¯¹åº”çš„FutureCallbackåšç»“æœçš„å¼‚æ­¥å›è°ƒã€‚å¼‚æ­¥éé˜»å¡

**Nettyå¼‚æ­¥å›è°ƒ**ï¼š

* Futureä½œä¸ºæ¥å£(å’ŒJavaè‡ªå¸¦çš„åŒåä¸åŒåŒ…)ï¼Œå¯¹åº”çš„GenericFutureListeneråšç»“æœçš„å¼‚æ­¥å›è°ƒã€‚å¼‚æ­¥éé˜»å¡
